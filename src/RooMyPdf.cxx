/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/

#include <complex>
#include <RooMath.h>
#include <chrono>
#include "Riostream.h"

#include "RooMyPdf.h"
#include "cuda_calculate.h"

ClassImp(RooMyPdf);

RooMyPdf::RooMyPdf(const char *name, const char *title,
                   RooAbsReal &_x,
                   RooAbsReal &_mean_1,
                   RooAbsReal &_mean_2,
                   RooAbsReal &_width_1,
                   RooAbsReal &_width_2,
                   RooAbsReal &_ratio,
                   bool _use_gpu,
                   int _bins) :
        RooAbsPdf(name, title),
        x("x", "x", this, _x),
        mean_1("mean_1", "mean_1", this, _mean_1),
        mean_2("mean_2", "mean_2", this, _mean_2),
        width_1("width_1", "width_1", this, _width_1),
        width_2("width_2", "width_2", this, _width_2),
        ratio("ratio", "ratio", this, _ratio),
        use_gpu(_use_gpu),
        bins(_bins)
{
}


RooMyPdf::RooMyPdf(const RooMyPdf &other, const char *name) :
        RooAbsPdf(other, name),
        x("x", this, other.x),
        mean_1("mean_1", this, other.mean_1),
        mean_2("mean_2", this, other.mean_2),
        width_1("width_1", this, other.width_1),
        width_2("width_2", this, other.width_2),
        ratio("ratio", this, other.ratio),
        use_gpu(other.use_gpu),
        bins(other.bins)
{
}

// f(t) = \frac{1}{(t-mean_1)^2+0.25 \times width_1^2} + a*\frac{1}{(t-mean_2)^2+0.25 \times width_2^2}
Double_t RooMyPdf::sub_f(Double_t t) const
{
    Double_t w1 = (width_1 > 0) ? width_1 : -width_1;
    Double_t w2 = (width_2 > 0) ? width_2 : -width_2;
    Double_t arg1 = t - mean_1;
    Double_t arg2 = t - mean_2;
    Double_t r = ratio;
    return (1. / (arg1 * arg1 + 0.25 * w1 * w1) + r / (arg2 * arg2 + 0.25 * w2 * w2));
}

// \sigma(t) = 10/sqrt(t)
Double_t RooMyPdf::sub_sigma(Double_t t) const
{
    return 10 / sqrt(t);
}

//  f(t) * \frac{1}{\sigma (t)} \exp{-\frac{(t-x)^2}{2*\sigma^2(t)}}
Double_t RooMyPdf::sub_evaluate(Double_t t) const
{
    Double_t s = (sub_sigma(t) > 0) ? sub_sigma(t) : -sub_sigma(t);
    Double_t arg = t - x;
    Double_t coef = -0.5 / (s * s);
    double_t result = sub_f(t) * exp(coef * arg * arg) * 1 / s;
    return result;
}

Double_t RooMyPdf::cuda_normal_evaluate() const
{
    Double_t upper = x.max() + 3 * sub_sigma(x.max());
    Double_t lower = x.min() - 3 * sub_sigma(x.min());
    return sub_cuda_normal_calculate(bins, lower, upper, x, mean_1, mean_2, width_1, width_2, ratio);
}

Double_t RooMyPdf::normal_evaluate() const
{
    Double_t upper = x.max() + 3 * sub_sigma(x.max());
    Double_t lower = x.min() - 3 * sub_sigma(x.min());
    double step = (upper - lower) / bins;
    double result = 0;
    for (int i = 0; i < bins; i++) {
        double point = lower + (i + 0.5) * step;
        result += sub_evaluate(point) * step;
    }
    return result;
}

Double_t RooMyPdf::evaluate() const
{
    if (this->use_gpu) {
        return cuda_normal_evaluate();
    } else {
        return normal_evaluate();
    }
}

